{"content":"<div id=\"rules\">\n<h1 id=\"section\">《叮铃叮铃》规则</h1>\n\n<h2 id=\"section-1\">介绍</h2>\n\n<p>《叮铃叮铃》是一款奇特的机会游戏，玩法是让一个球沿着布满了木钉的竖直的木板“叮铃叮铃”地落下。这是 20 世纪电视节目中非常流行的游戏。  Bgaming 以金字塔的形式代表木板。 游戏玩法很简单：玩家从 8 到 16 行中进行选择，希望球能落入所选回报最高的一个洞中，然后只需观看球从金字塔顶部到木板底部“穿过障碍物的弹跳过程”。 球最终落在底部木钉处，并决定奖励。 所以欢迎来到《叮铃叮铃》复杂的系统，相信运气，让球落下！</p>\n\n<h2 id=\"section-2\">规则</h2>\n\n<p>目标是通过叮铃球落下来赢钱，然后等到球落在木板底部最大金额的槽里。</p>\n\n<h2 id=\"section-3\">下注</h2>\n\n<p>选择下注金额。 可以使用 ** “-” ** 、 ** “+” ** 、 ** “最小” ** 、 ** “最大” ** 按钮。 当达到最大金额时， ** “+” ** 和 ** “最大” ** 按钮将被禁用。 当达到最小金额时， ** “-” ** 和 ** “最小” ** 按钮将被禁用。 选择风险级别：低、正常或高。 选择游戏中的行数：从 8 到 16。 选择投注模式：手动或自动。</p>\n\n<p>要开始游戏回合，请按 ** 开玩 ** 按钮。 除 ** 投注模式 ** 外，所有下注按钮在该轮进行时变为无效。 在游戏回合中，可以使用 ** 开玩 ** 按钮开始具有相同设置的另一轮游戏。 在每个回合结束时，球会到达口袋。 每个口袋中显示的数字代表乘数值。 玩家的投注额会以球落下位置口袋的乘数来计算。 最后的奖金会以的玩家的投注额乘以所有适用乘数来计算。</p>\n\n<p>在 <strong>自动模式</strong>下，该字段将显示自动投注的次数。 选择 ** 投注次数 ** 。 按 ** 开始 ** 按钮。 随着剩余投注次数增加， ** 开始 ** 按钮将更改为 ** 停止 ** 。 如果余额中没有足够的资金，若达到设置的回合数量，单击 ** 停止 ** 按钮可完成一个系列回合。</p>\n\n<p><span class=\"min_max_bet\">最小下注额为 {min_bet}。 最大下注额为 {max_bet}。</span></p>\n\n<h2 id=\"section-4\">结果</h2>\n\n<p>根据赔付表计算派彩金额。 结果将添加到显示的余额中。 派彩金额从低到高不等。</p>\n\n<div class=\"license-block-casual casual_custom_license\">\n\n  <h2 id=\"section-5\">授权许可要求</h2>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\n根据运用商适用的管理许可，本游戏中的“自动开始”可能会无法正常使用。\n</span></p>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\n根据博彩运营商管理许可的不同，本游戏中的“快速旋转”可能会无法正常使用。\n</span></p>\n\n  <p><span class=\"casual_custom_license\"> 根据博彩运营商管理许可的不同，本游戏中可能无法通过“开始游戏”按钮再开启一轮相同设定的游戏回合。 在这种情况下，在当前回合结束以及最终结果显示之前，“开始游戏”按钮将一直保持在不可用状态。 每次只能玩一个回合。</span></p>\n\n</div>\n\n<h2 id=\"section-6\">玩家返利</h2>\n\n<p>总体理论上的玩家回报率 (RTP) 为 {RTP.min_rtp}% - {RTP.max_rtp}%，这最终将取决于玩家所采用的策略。</p>\n\n<p>发生故障，所有支付及游戏均作废！ 所有未完成的回合 24 小时之后都将终止。 如果本游戏提供部分奖金“领取”功能，会出现“领取”按钮，领取的奖金将被汇总至玩家资金余额中。 如果游戏要求玩家进行操作，则会计算结果，同时假定玩家已经选择无风险的操作，且不会提高初始赌注。</p>\n\n<p><span class=\"game_version\">游戏版本{game_version}。</span></p>\n\n<p>本网站上发布的游戏规则是英文版。翻译成其它语言是为了提供更好的服务。 如果英文原本与译文有出入，请优先以英文版本为主。</p>\n</div>\n","contentUpdateScript":"const casinoOptions = window.__OPTIONS__;\nlet customRulesStyle = '';\n\nif (casinoOptions?.math?.gamble_limit) {\n    content = content.replaceAll('{GAMBLE_LIMIT}', casinoOptions.math.gamble_limit);\n}\n\n//INFO: temporary solution for BGG-7896 & BGG-11170, but we need more flexible solution\nconst licenseDisabled = [\"empty\", \"switzerland\"];\nconst rulesLicense = casinoOptions?.license_rules?.license ?? \"empty\";\nif (licenseDisabled.includes(rulesLicense)) {\n    customRulesStyle += ` .license-block { display: none } `;\n}\n\nif (rulesLicense === \"empty\") {\n\tcustomRulesStyle += ` .license-block-casual { display: none } `;\n}\n\n// BGG-11165: Allow custom rules for any license\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license { display: none } `;\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license.${rulesLicense} { display: unset } `;\n\nif (casinoOptions?.ui?.show_rtp_in_rules === false) {\n    const rtpRegExp = /<h\\d[^>]*>[^>]*<\\/h\\d>[^<]*<p>[^<]*(\\{RTP.+\\}|\\d[^<]*%)[^<]*<\\/p>[^<]*/;\n\n    content = content.replace(rtpRegExp, '');\n}\n\nif (casinoOptions?.math?.rtp) {\n    if (!isNaN(casinoOptions.math.rtp)) {\n        casinoOptions.math.rtp = { main: casinoOptions.math.rtp };\n    }\n\n    content = content.replaceAll(`{RTP_VALUE}`, `{RTP.main}`);\n    Object.keys(casinoOptions.math.rtp).forEach((key) => {\n        content = content.replaceAll(`{RTP.${key}}`, casinoOptions.math.rtp[key]);\n    });\n}\n\nif (casinoOptions?.custom?.paytableFormatted) {\n    Object.keys(casinoOptions.custom.paytableFormatted).forEach((key) => {\n        content = content.replaceAll(`{PAYTABLE.${key}}`, casinoOptions.custom.paytableFormatted[key]);\n    });\n}\n\nif (casinoOptions?.custom?.wintableFormatted) {\n\tObject.keys(casinoOptions.custom.wintableFormatted).forEach((key) => {\n\t\tcontent = content.replaceAll(`{WIN.${key}}`, casinoOptions.custom.wintableFormatted[key]);\n\t});\n}\n\nif (casinoOptions?.custom?.maxWinsFormatted) {\n    casinoOptions.custom.maxWinsFormatted.forEach((winFormatted, index) => {\n        content = content.replaceAll(`{MAX_WIN.${index}}`, winFormatted);\n    });\n}\n\nif (casinoOptions?.custom?.betFormatted) {\n    content = content.replaceAll(`{BET_FORMATTED}`, casinoOptions.custom.betFormatted);\n}\n\nif (customRulesStyle !== '') {\n    content = '<style>' + customRulesStyle + '</style>' + content;\n}\n\nreturn content;\n\n","domScripts":["(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction formatBet(bet, subunits, exponent = 0) {\n    const betValue = bet / subunits;\n    let ret;\n\n    if (exponent > 0) {\n        let str = betValue.toFixed(exponent).split('.');\n        if (str[0].length > 3) {\n            str[0] = str[0].replace(/(.)(?=(.{3})+$)/g, '$1 ');\n        }\n        ret = str.join('.');\n    } else {\n        ret = betValue.toFixed(0).replace(/(.)(?=(.{3})+$)/g, '$1 ');\n    }\n    return ret;\n}\n\nfunction setMinMaxBets(options) {\n    const { rules, license_rules } = options;\n    const { min_bet, max_bet, currency } = rules || {};\n    const { symbol, exponent, subunits } = currency || {};\n\n    const isNeedToRemoveMinMaxBetBlock =\n        license_rules?.license !== 'switzerland' && license_rules?.license !== 'danish' && license_rules?.license !== 'swedish';\n    document.querySelectorAll('.min_max_bet').forEach((fragment) => {\n        if (isNeedToRemoveMinMaxBetBlock || (!min_bet && !max_bet)) {\n            fragment.remove();\n        } else {\n            const currencySymbol = symbol || '';\n            const minBet = formatBet(min_bet, subunits, exponent);\n            const maxBet = formatBet(max_bet, subunits, exponent);\n            fragment.textContent = fragment.textContent.replace('{min_bet}', `${minBet} ${currencySymbol}`);\n            fragment.textContent = fragment.textContent.replace('{max_bet}', `${maxBet} ${currencySymbol}`);\n        }\n    });\n}\n\nsetMinMaxBets(casinoOptions);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\nconst customLicenses = ['netherlands', 'swedish', 'italian', 'switzerland'];\n\nfunction handleCustomLicenses(options, customLicenses) {\n\tdocument.querySelectorAll('.casual_custom_license').forEach((fragment) => {\n\t\tif (!customLicenses.includes(options?.license_rules?.license)) {\n\t\t\tfragment.remove();\n\t\t}\n\t});\n}\n\nhandleCustomLicenses(casinoOptions, customLicenses);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction handleGameVersion(options) {\n    const gameVersion = options?.version;\n\n    document.querySelectorAll('.game_version').forEach((fragment) => {\n        if (!gameVersion) {\n            fragment.remove();\n        } else {\n            fragment.textContent = fragment.textContent.replaceAll('{game_version}', `${gameVersion}`);\n        }\n    });\n}\n\nhandleGameVersion(casinoOptions);\n\n})()\n","(()=>{\nconst PURCHASE_KEYS_REGEX = /buy|chance/;\nconst NETHERLANDS_RTP_TO_RENDER = /(main|chance)/;\n\nfunction getFinalRtpValues(options, isNeedRemovePurchasesRtp) {\n    const rtp = options?.math?.rtp ?? null;\n\n    if (!rtp || !isNeedRemovePurchasesRtp) return rtp;\n\n    return Object.entries(rtp).reduce((result, [rtpName, rtpValue]) => {\n        if (!PURCHASE_KEYS_REGEX.test(rtpName)) {\n            result[rtpName] = rtpValue;\n        }\n        return result;\n    }, {});\n}\n\nfunction removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemovePurchasesRtp && PURCHASE_KEYS_REGEX.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemoveRtp && !NETHERLANDS_RTP_TO_RENDER.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction replaceContent() {\n    const casinoOptions = window.__OPTIONS__;\n\n    const rulesLicense = casinoOptions?.license_rules?.license ?? 'empty';\n    const isNeedRemovePurchasesRtp = rulesLicense === 'greek';\n    const isNeedRemovePurchasesRtpForNetherlands = rulesLicense === 'netherlands';\n    const isNeedRemovePurchasesRtpForPortuguese = rulesLicense === 'portuguese';\n    const isNeedRemoveRtp = isNeedRemovePurchasesRtpForNetherlands || isNeedRemovePurchasesRtpForPortuguese;\n\n    const rtp = getFinalRtpValues(casinoOptions, isNeedRemovePurchasesRtp);\n    removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp);\n    removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp);\n}\n\nreplaceContent();\n\n})()\n"]}