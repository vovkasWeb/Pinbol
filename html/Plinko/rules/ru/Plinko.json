{"content":"<div id=\"rules\">\n<h1 id=\"plinko\">Правила Plinko</h1>\n\n<h2 id=\"section\">Введение</h2>\n\n<p>Plinko - игра на удачу, которая была на пике популярности во второй половине 20 века на различных ТВ-шоу. Основные атрибуты игры - шарик и вертикальная доска с препятствиями.  BGaming немного отошел от классического вида игральной доски Plinko, у нас она представлена в форме пирамиды. Ход игры прост: игрок выбирает от 8 до 16  рядов, запускает шар и наблюдает за процессом  его “прыжков” сверху вниз по игральной доске. В конечном итоге, шар попадает в одну из нижних лунок и игрок получает определенные выплаты. Plinko, несмотря на простоту, отличается особой интригой, так что поскорее запускайте шарик и выигрывайте призы!</p>\n\n<h2 id=\"section-1\">Правила игры</h2>\n\n<p>Цель игры – выиграть как можно больше денежных призов, бросая шарик с верхушки пирамиды.</p>\n\n<h2 id=\"section-2\">Ставки</h2>\n\n<p>Выберите размер ставки. Могут быть использованы кнопки <strong>“-”</strong>, <strong>“+”</strong>, <strong>“Мин”</strong>, <strong>“Макс”</strong>. Когда достигнуто максимальное количество,  кнопки <strong>“+”</strong> и <strong>“Макс”</strong> становятся неактивными. Когда достигнуто минимальное количество, кнопки <strong>“-”</strong> и <strong>“Мин”</strong> становятся неактивными. Выберите уровень риска: Низкий, Средний или Высокий. Выберите количество Линий в игре: от 8 до 16. Выберите режим ставки: Ручной или Авто.</p>\n\n<p>Нажмите кнопку <strong>Играть</strong>, чтобы начать раунд. Все кнопки, касающиеся ставок, становятся неактивными, за исключением <strong>Режима ставки</strong>. Во время раунда с помощью кнопки <strong>Играть</strong> может быть начат другой раунд с теми же настройками ставок. В конце каждого раунда шарик попадает в ячейку. Числа, отображаемые в каждой ячейке, представляют собой значения множителя. Множитель ячейки, в которую приземлился шарик, применяется к ставке игрока. Конечная выплата рассчитывается умножением ставки игрока на все применимые значения множителей.</p>\n\n<p>В <strong>Авторежиме</strong> отображается поле с количеством автоматических ставок. Выберите <strong>количество ставок</strong>. Нажмите кнопку <strong>Играть</strong>. В данном режиме кнопка <strong>Играть</strong> меняется на <strong>Стоп</strong> с количеством оставшихся ставок. Серия раундов может быть завершена в случаях, когда закончились ставки, если недостаточно средств на балансе или же вручную была нажата кнопка <strong>Стоп</strong>.</p>\n\n<p><span class=\"min_max_bet\">Минимальная ставка составляет {min_bet}. Максимальная ставка составляет составляет {max_bet}.</span></p>\n\n<h2 id=\"section-3\">Результаты</h2>\n\n<p>Подсчет выигрыша осуществляется в соответствии с таблицей выплат. Результат прибавляется к балансу игрока. Размер выплат варьируется от низкого до высокого.</p>\n\n<div class=\"license-block-casual casual_custom_license\">\n\n  <h2 id=\"section-4\">Требования лицензии</h2>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nАвторежим может быть недоступен в игре из-за требований лицензии, регулирующей работу оператора.\n</span></p>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nБыстрые вращения могут быть недоступны в игре из-за требований лицензии, регулирующей работу оператора.\n</span></p>\n\n  <p><span class=\"casual_custom_license\">Возможность начать следующий раунд с теми же настройками, нажав на кнопку “Играть” во время текущего раунда, может быть недоступна в игре из-за требований лицензии, регулирующей работу оператора. В этом случае кнопка “Играть” будет недоступна до завершения текущего раунда и показа результатов. Единовременно можно играть только один раунд.</span></p>\n\n</div>\n\n<h2 id=\"section-5\">Процент возврата игроку</h2>\n\n<p>Общий процент возврата игроку от суммы внесенных средств составляет {RTP.min_rtp}% - {RTP.max_rtp}%, в зависимости от стратегии, выбранной игроком.</p>\n\n<p>В случае сбоев в игре все сыгранные раунды и выигрыши в них аннулируются! Каждые 24 часа происходит завершение всех незавершенных раундов. Если в игре доступен “Коллект” - игра сделает “Коллект” и выигрыш будет зачислен на баланс игрока. Если игра ожидает действия игрока, то результат рассчитывается таким образом, как если бы игрок выбрал действие без риска и повышения первоначальной ставки.</p>\n\n<p><span class=\"game_version\">Версия игры {game_version}.</span></p>\n\n<p>Правила игры составлены на английском языке. Переводы на другие языки являются достоверными. В случае расхождений между английской версией и переводом преимущественную силу имеет английская версия.</p>\n</div>\n","contentUpdateScript":"const casinoOptions = window.__OPTIONS__;\nlet customRulesStyle = '';\n\nif (casinoOptions?.math?.gamble_limit) {\n    content = content.replaceAll('{GAMBLE_LIMIT}', casinoOptions.math.gamble_limit);\n}\n\n//INFO: temporary solution for BGG-7896 & BGG-11170, but we need more flexible solution\nconst licenseDisabled = [\"empty\", \"switzerland\"];\nconst rulesLicense = casinoOptions?.license_rules?.license ?? \"empty\";\nif (licenseDisabled.includes(rulesLicense)) {\n    customRulesStyle += ` .license-block { display: none } `;\n}\n\nif (rulesLicense === \"empty\") {\n\tcustomRulesStyle += ` .license-block-casual { display: none } `;\n}\n\n// BGG-11165: Allow custom rules for any license\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license { display: none } `;\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license.${rulesLicense} { display: unset } `;\n\nif (casinoOptions?.ui?.show_rtp_in_rules === false) {\n    const rtpRegExp = /<h\\d[^>]*>[^>]*<\\/h\\d>[^<]*<p>[^<]*(\\{RTP.+\\}|\\d[^<]*%)[^<]*<\\/p>[^<]*/;\n\n    content = content.replace(rtpRegExp, '');\n}\n\nif (casinoOptions?.math?.rtp) {\n    if (!isNaN(casinoOptions.math.rtp)) {\n        casinoOptions.math.rtp = { main: casinoOptions.math.rtp };\n    }\n\n    content = content.replaceAll(`{RTP_VALUE}`, `{RTP.main}`);\n    Object.keys(casinoOptions.math.rtp).forEach((key) => {\n        content = content.replaceAll(`{RTP.${key}}`, casinoOptions.math.rtp[key]);\n    });\n}\n\nif (casinoOptions?.custom?.paytableFormatted) {\n    Object.keys(casinoOptions.custom.paytableFormatted).forEach((key) => {\n        content = content.replaceAll(`{PAYTABLE.${key}}`, casinoOptions.custom.paytableFormatted[key]);\n    });\n}\n\nif (casinoOptions?.custom?.wintableFormatted) {\n\tObject.keys(casinoOptions.custom.wintableFormatted).forEach((key) => {\n\t\tcontent = content.replaceAll(`{WIN.${key}}`, casinoOptions.custom.wintableFormatted[key]);\n\t});\n}\n\nif (casinoOptions?.custom?.maxWinsFormatted) {\n    casinoOptions.custom.maxWinsFormatted.forEach((winFormatted, index) => {\n        content = content.replaceAll(`{MAX_WIN.${index}}`, winFormatted);\n    });\n}\n\nif (casinoOptions?.custom?.betFormatted) {\n    content = content.replaceAll(`{BET_FORMATTED}`, casinoOptions.custom.betFormatted);\n}\n\nif (customRulesStyle !== '') {\n    content = '<style>' + customRulesStyle + '</style>' + content;\n}\n\nreturn content;\n\n","domScripts":["(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction formatBet(bet, subunits, exponent = 0) {\n    const betValue = bet / subunits;\n    let ret;\n\n    if (exponent > 0) {\n        let str = betValue.toFixed(exponent).split('.');\n        if (str[0].length > 3) {\n            str[0] = str[0].replace(/(.)(?=(.{3})+$)/g, '$1 ');\n        }\n        ret = str.join('.');\n    } else {\n        ret = betValue.toFixed(0).replace(/(.)(?=(.{3})+$)/g, '$1 ');\n    }\n    return ret;\n}\n\nfunction setMinMaxBets(options) {\n    const { rules, license_rules } = options;\n    const { min_bet, max_bet, currency } = rules || {};\n    const { symbol, exponent, subunits } = currency || {};\n\n    const isNeedToRemoveMinMaxBetBlock =\n        license_rules?.license !== 'switzerland' && license_rules?.license !== 'danish' && license_rules?.license !== 'swedish';\n    document.querySelectorAll('.min_max_bet').forEach((fragment) => {\n        if (isNeedToRemoveMinMaxBetBlock || (!min_bet && !max_bet)) {\n            fragment.remove();\n        } else {\n            const currencySymbol = symbol || '';\n            const minBet = formatBet(min_bet, subunits, exponent);\n            const maxBet = formatBet(max_bet, subunits, exponent);\n            fragment.textContent = fragment.textContent.replace('{min_bet}', `${minBet} ${currencySymbol}`);\n            fragment.textContent = fragment.textContent.replace('{max_bet}', `${maxBet} ${currencySymbol}`);\n        }\n    });\n}\n\nsetMinMaxBets(casinoOptions);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\nconst customLicenses = ['netherlands', 'swedish', 'italian', 'switzerland'];\n\nfunction handleCustomLicenses(options, customLicenses) {\n\tdocument.querySelectorAll('.casual_custom_license').forEach((fragment) => {\n\t\tif (!customLicenses.includes(options?.license_rules?.license)) {\n\t\t\tfragment.remove();\n\t\t}\n\t});\n}\n\nhandleCustomLicenses(casinoOptions, customLicenses);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction handleGameVersion(options) {\n    const gameVersion = options?.version;\n\n    document.querySelectorAll('.game_version').forEach((fragment) => {\n        if (!gameVersion) {\n            fragment.remove();\n        } else {\n            fragment.textContent = fragment.textContent.replaceAll('{game_version}', `${gameVersion}`);\n        }\n    });\n}\n\nhandleGameVersion(casinoOptions);\n\n})()\n","(()=>{\nconst PURCHASE_KEYS_REGEX = /buy|chance/;\nconst NETHERLANDS_RTP_TO_RENDER = /(main|chance)/;\n\nfunction getFinalRtpValues(options, isNeedRemovePurchasesRtp) {\n    const rtp = options?.math?.rtp ?? null;\n\n    if (!rtp || !isNeedRemovePurchasesRtp) return rtp;\n\n    return Object.entries(rtp).reduce((result, [rtpName, rtpValue]) => {\n        if (!PURCHASE_KEYS_REGEX.test(rtpName)) {\n            result[rtpName] = rtpValue;\n        }\n        return result;\n    }, {});\n}\n\nfunction removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemovePurchasesRtp && PURCHASE_KEYS_REGEX.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemoveRtp && !NETHERLANDS_RTP_TO_RENDER.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction replaceContent() {\n    const casinoOptions = window.__OPTIONS__;\n\n    const rulesLicense = casinoOptions?.license_rules?.license ?? 'empty';\n    const isNeedRemovePurchasesRtp = rulesLicense === 'greek';\n    const isNeedRemovePurchasesRtpForNetherlands = rulesLicense === 'netherlands';\n    const isNeedRemovePurchasesRtpForPortuguese = rulesLicense === 'portuguese';\n    const isNeedRemoveRtp = isNeedRemovePurchasesRtpForNetherlands || isNeedRemovePurchasesRtpForPortuguese;\n\n    const rtp = getFinalRtpValues(casinoOptions, isNeedRemovePurchasesRtp);\n    removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp);\n    removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp);\n}\n\nreplaceContent();\n\n})()\n"]}