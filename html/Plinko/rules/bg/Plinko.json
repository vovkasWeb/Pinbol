{"content":"<div id=\"rules\">\n<h1 id=\"plinko\">Правила на Plinko</h1>\n\n<h2 id=\"section\">Въведение</h2>\n\n<p>Plinko е особена игра на късмета, която се играе с топка, която се движи по вертикална дъска с редици от колчета, много популярна игра, излъчвана по телевизионните предавания през 20 век.  BGaming изобрази дъската под формата на пирамида. Принципът на игра е много прост: играчът избира от 8 до 16 реда, надявайки се топката да попадне в една от избраните дупки с най-добро заплащане, и просто наблюдава „процеса на отскачане през препятствията“ от върха на пирамидата надолу към дъното на дъската. В крайна сметка топката се озовава на най-долното колче и определя наградата. Така че заповядайте в сложната система на Plinko, доверете се на късмета си и оставете топката да падне!</p>\n\n<h2 id=\"section-1\">Правила</h2>\n\n<p>Целта е да спечелите пари, като пуснете топката Plinko и изчакате тя да се приземи в слота с най-много пари в долната част на таблото.</p>\n\n<h2 id=\"section-2\">Залагане</h2>\n\n<p>Изберете размера на залога. Могат да се използват бутони <strong>”-“</strong>, <strong>”+”</strong>, <strong>“Min”</strong>, <strong>“Max”</strong>. Когато се достигне максималната сума, бутоните <strong>”+”</strong> и <strong>“Max”</strong> се деактивират. Когато се достигне минималната сума, бутоните <strong>”-“</strong> и <strong>“Min”</strong> се деактивират. Изберете нивото на риска: нисък, нормален или висок. Изберете броя на линиите в играта: от 8 до 16. Изберете режим на залагане: ръчно или автоматично.</p>\n\n<p>За да стартирате игровия рунд, натиснете бутона <strong>„Игра“</strong>. Всички бутони за залагане стават неактивни по време на рунда, с изключение на <strong>„Режим на залагане“</strong>. По време на рунда може да се стартира друг рунд със същите настройки, като се използва бутонът <strong>„Игра“</strong>. В края на всеки рунд топката стига до джоба. Числата, показани във всеки джоб, представляват стойности на множителя. Коефициентът на джоба, в който е паднала топката, се прилага към залога на играча. Крайната печалба се изчислява, като залогът на играча се умножи по всички приложими стойности на множителя.</p>\n\n<p>В <strong>Автоматичен режим</strong> се показва полето с броя на автоматичните залози. Изберете <strong>броя на залозите</strong>. Натиснете бутона <strong>Play</strong>. Бутонът <strong>Play</strong> се променя на <strong>Stop</strong> с броя на оставащите залози. Поредицата от рундове може да бъде завършена, ако се достигне зададеният брой рундове, като кликнете върху бутона <strong>Стоп</strong>, ако в баланса няма достатъчно средства.</p>\n\n<p><span class=\"min_max_bet\">Стойността на минималния залог е {min_bet}. Максималната стойност на залога е {max_bet}</span></p>\n\n<h2 id=\"section-3\">Резултати</h2>\n\n<p>Печалбата се изчислява в съответствие с таблицата с печалбите. Резултатът се добавя към полето за баланс. Размерът на плащанията варира от нисък до висок.</p>\n\n<div class=\"license-block-casual casual_custom_license\">\n\n  <h2 id=\"section-4\">Лицензионни изисквания</h2>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nАвтоматичният режим може да не е достъпен в играта поради изискванията на лиценза, който регулира работата на оператора.\n</span></p>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nБързите завъртания може да не са налични в играта поради изискванията на лиценза, който регулира работата на оператора.\n</span></p>\n\n  <p><span class=\"casual_custom_license\"> Възможността за започване на нов рунд със същите настройки чрез бутона „Игра“ по време на текущия рунд може да не е налична в играта поради лиценза, който регулира работата на оператора. В този случай бутонът „Игра“ ще остане неактивен, докато не приключи текущият рунд и не се покажат резултатите. В един и същи момент може да се играе само един кръг.</span></p>\n\n</div>\n\n<h2 id=\"section-5\">Възвръщаемост за играча</h2>\n\n<p>Общата теоретична възвръщаемост за играча (RTP) е {RTP.min_rtp}% - {RTP.max_rtp}% в зависимост от избраната от играча стратегия.</p>\n\n<p>Всяка неизправност анулира всички игри и плащания! Всички незавършени рундове ще бъдат прекратявани на всеки 24 часа. Ако играта изисква „Събиране“ – „Събирането“ ще се извърши и печалбата от рунда ще бъде добавена към баланса на играча. Ако играта изисква действие от играча, резултатът се брои, като се приема, че играчът е избрал действието без риск, без да повишава първоначалния залог.</p>\n\n<p><span class=\"game_version\">Версия на играта {game_version}.</span></p>\n\n<p>Правилата на играта, публикувани на този уебсайт, са на английски език. Преводите на други езици се предоставят като добронамерена услуга. В случай на противоречие между английската версия и превода, английската версия винаги запазва приоритет.</p>\n</div>\n","contentUpdateScript":"const casinoOptions = window.__OPTIONS__;\nlet customRulesStyle = '';\n\nif (casinoOptions?.math?.gamble_limit) {\n    content = content.replaceAll('{GAMBLE_LIMIT}', casinoOptions.math.gamble_limit);\n}\n\n//INFO: temporary solution for BGG-7896 & BGG-11170, but we need more flexible solution\nconst licenseDisabled = [\"empty\", \"switzerland\"];\nconst rulesLicense = casinoOptions?.license_rules?.license ?? \"empty\";\nif (licenseDisabled.includes(rulesLicense)) {\n    customRulesStyle += ` .license-block { display: none } `;\n}\n\nif (rulesLicense === \"empty\") {\n\tcustomRulesStyle += ` .license-block-casual { display: none } `;\n}\n\n// BGG-11165: Allow custom rules for any license\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license { display: none } `;\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license.${rulesLicense} { display: unset } `;\n\nif (casinoOptions?.ui?.show_rtp_in_rules === false) {\n    const rtpRegExp = /<h\\d[^>]*>[^>]*<\\/h\\d>[^<]*<p>[^<]*(\\{RTP.+\\}|\\d[^<]*%)[^<]*<\\/p>[^<]*/;\n\n    content = content.replace(rtpRegExp, '');\n}\n\nif (casinoOptions?.math?.rtp) {\n    if (!isNaN(casinoOptions.math.rtp)) {\n        casinoOptions.math.rtp = { main: casinoOptions.math.rtp };\n    }\n\n    content = content.replaceAll(`{RTP_VALUE}`, `{RTP.main}`);\n    Object.keys(casinoOptions.math.rtp).forEach((key) => {\n        content = content.replaceAll(`{RTP.${key}}`, casinoOptions.math.rtp[key]);\n    });\n}\n\nif (casinoOptions?.custom?.paytableFormatted) {\n    Object.keys(casinoOptions.custom.paytableFormatted).forEach((key) => {\n        content = content.replaceAll(`{PAYTABLE.${key}}`, casinoOptions.custom.paytableFormatted[key]);\n    });\n}\n\nif (casinoOptions?.custom?.wintableFormatted) {\n\tObject.keys(casinoOptions.custom.wintableFormatted).forEach((key) => {\n\t\tcontent = content.replaceAll(`{WIN.${key}}`, casinoOptions.custom.wintableFormatted[key]);\n\t});\n}\n\nif (casinoOptions?.custom?.maxWinsFormatted) {\n    casinoOptions.custom.maxWinsFormatted.forEach((winFormatted, index) => {\n        content = content.replaceAll(`{MAX_WIN.${index}}`, winFormatted);\n    });\n}\n\nif (casinoOptions?.custom?.betFormatted) {\n    content = content.replaceAll(`{BET_FORMATTED}`, casinoOptions.custom.betFormatted);\n}\n\nif (customRulesStyle !== '') {\n    content = '<style>' + customRulesStyle + '</style>' + content;\n}\n\nreturn content;\n\n","domScripts":["(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction formatBet(bet, subunits, exponent = 0) {\n    const betValue = bet / subunits;\n    let ret;\n\n    if (exponent > 0) {\n        let str = betValue.toFixed(exponent).split('.');\n        if (str[0].length > 3) {\n            str[0] = str[0].replace(/(.)(?=(.{3})+$)/g, '$1 ');\n        }\n        ret = str.join('.');\n    } else {\n        ret = betValue.toFixed(0).replace(/(.)(?=(.{3})+$)/g, '$1 ');\n    }\n    return ret;\n}\n\nfunction setMinMaxBets(options) {\n    const { rules, license_rules } = options;\n    const { min_bet, max_bet, currency } = rules || {};\n    const { symbol, exponent, subunits } = currency || {};\n\n    const isNeedToRemoveMinMaxBetBlock =\n        license_rules?.license !== 'switzerland' && license_rules?.license !== 'danish' && license_rules?.license !== 'swedish';\n    document.querySelectorAll('.min_max_bet').forEach((fragment) => {\n        if (isNeedToRemoveMinMaxBetBlock || (!min_bet && !max_bet)) {\n            fragment.remove();\n        } else {\n            const currencySymbol = symbol || '';\n            const minBet = formatBet(min_bet, subunits, exponent);\n            const maxBet = formatBet(max_bet, subunits, exponent);\n            fragment.textContent = fragment.textContent.replace('{min_bet}', `${minBet} ${currencySymbol}`);\n            fragment.textContent = fragment.textContent.replace('{max_bet}', `${maxBet} ${currencySymbol}`);\n        }\n    });\n}\n\nsetMinMaxBets(casinoOptions);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\nconst customLicenses = ['netherlands', 'swedish', 'italian', 'switzerland'];\n\nfunction handleCustomLicenses(options, customLicenses) {\n\tdocument.querySelectorAll('.casual_custom_license').forEach((fragment) => {\n\t\tif (!customLicenses.includes(options?.license_rules?.license)) {\n\t\t\tfragment.remove();\n\t\t}\n\t});\n}\n\nhandleCustomLicenses(casinoOptions, customLicenses);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction handleGameVersion(options) {\n    const gameVersion = options?.version;\n\n    document.querySelectorAll('.game_version').forEach((fragment) => {\n        if (!gameVersion) {\n            fragment.remove();\n        } else {\n            fragment.textContent = fragment.textContent.replaceAll('{game_version}', `${gameVersion}`);\n        }\n    });\n}\n\nhandleGameVersion(casinoOptions);\n\n})()\n","(()=>{\nconst PURCHASE_KEYS_REGEX = /buy|chance/;\nconst NETHERLANDS_RTP_TO_RENDER = /(main|chance)/;\n\nfunction getFinalRtpValues(options, isNeedRemovePurchasesRtp) {\n    const rtp = options?.math?.rtp ?? null;\n\n    if (!rtp || !isNeedRemovePurchasesRtp) return rtp;\n\n    return Object.entries(rtp).reduce((result, [rtpName, rtpValue]) => {\n        if (!PURCHASE_KEYS_REGEX.test(rtpName)) {\n            result[rtpName] = rtpValue;\n        }\n        return result;\n    }, {});\n}\n\nfunction removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemovePurchasesRtp && PURCHASE_KEYS_REGEX.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemoveRtp && !NETHERLANDS_RTP_TO_RENDER.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction replaceContent() {\n    const casinoOptions = window.__OPTIONS__;\n\n    const rulesLicense = casinoOptions?.license_rules?.license ?? 'empty';\n    const isNeedRemovePurchasesRtp = rulesLicense === 'greek';\n    const isNeedRemovePurchasesRtpForNetherlands = rulesLicense === 'netherlands';\n    const isNeedRemovePurchasesRtpForPortuguese = rulesLicense === 'portuguese';\n    const isNeedRemoveRtp = isNeedRemovePurchasesRtpForNetherlands || isNeedRemovePurchasesRtpForPortuguese;\n\n    const rtp = getFinalRtpValues(casinoOptions, isNeedRemovePurchasesRtp);\n    removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp);\n    removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp);\n}\n\nreplaceContent();\n\n})()\n"]}