{"content":"<div id=\"rules\">\n<h1 id=\"reglas-de-plinko\">Reglas de Plinko</h1>\n\n<h2 id=\"introduccin\">Introducción</h2>\n\n<p>Plinko es un peculiar juego de azar en el cual una bola se desplaza rebotando hacia abajo en una tabla vertical repleta de filas, juego muy popular visto en programas de televisión durante el siglo XX.  BGaming muestra el tablero en forma de pirámide. El juego es tan simple como: el jugador elige de 8 a 16 filas, esperando que la bola caiga en uno de los agujeros elegidos con el mejor pago, y solo observa el «proceso de rebote a través de los obstáculos» desde la parte superior de la pirámide, hasta abajo de la misma. La bola termina finalmente en la línea inferior y determina el premio. Así que le damos la bienvenida al complicado sistema de Plinko, ¡confíe en su suerte y deje caer la bola!</p>\n\n<h2 id=\"reglas\">Reglas</h2>\n\n<p>El objetivo es ganar dinero lanzando la bola de Plinko y esperar hasta que caiga en la ranura de dinero más valiosa en la parte inferior del tablero.</p>\n\n<h2 id=\"apuestas\">Apuestas</h2>\n\n<p>Elija el importe de la apuesta. Se pueden usar los botones <strong>«-»</strong>, <strong>«+»</strong>, <strong>«Mín.»</strong>, <strong>«Máx»</strong>. Cuando se alcanza la cantidad máxima, los botones <strong>«+»</strong> y <strong>«Máx»</strong> se desactivan. Cuando se alcanza la cantidad mínima, los botones <strong>«-»</strong> y <strong>«Mín.»</strong> se desactivan. Elija el nivel de riesgo: bajo, normal o alto. Elija el número de Líneas en el juego: de 8 a 16. Elija el Modo de Apuesta: Manual o Automático.</p>\n\n<p>Para iniciar la ronda de juego, pulse el botón <strong>Jugar</strong>. Todos los botones de apuesta quedan inactivos en el momento de la ronda, excepto <strong>Modo de Apuesta</strong>. Durante la ronda, se puede iniciar otra ronda con los mismos ajustes usando el botón <strong>Jugar</strong>. Al final de cada ronda, la bola llega al hueco. Los números que aparecen en cada hueco representan valores multiplicadores. El multiplicador del hueco, donde cayó la bola, se aplica a la apuesta del jugador. El pago final se calcula multiplicando la apuesta del jugador por todos los valores multiplicadores aplicables.</p>\n\n<p>En <strong>Modo automático</strong>, se muestra el campo con el número de apuestas automáticas. Elija el <strong>número de apuestas</strong>. Pulse el botón <strong>Jugar</strong>. El botón <strong>Jugar</strong> cambia a <strong>Detener</strong> con el número de apuestas restantes. Se puede completar una serie de rondas si se alcanza el número de rondas, haciendo clic en el botón <strong>Detener</strong>, si no hay suficientes fondos en el saldo.</p>\n\n<p><span class=\"min_max_bet\">La apuesta mínima es {min_bet}. La apuesta máxima es {max_bet}</span></p>\n\n<h2 id=\"resultados\">Resultados</h2>\n\n<p>El cálculo de la ganancia se realiza de acuerdo a la tabla de ganancias. El resultado se añade al saldo. El tamaño de los pagos varía de bajo a alto.</p>\n\n<div class=\"license-block-casual casual_custom_license\">\n\n  <h2 id=\"requisitos-de-licencia\">Requisitos de licencia</h2>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nEl modo automático puede no estar disponible en el juego debido a los requisitos de la licencia que regula el trabajo del operador.\n</span></p>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nLas tiradas rápidas pueden no estar disponibles en el juego debido a los requisitos de la licencia que regula el trabajo del operador.\n</span></p>\n\n  <p><span class=\"casual_custom_license\"> La posibilidad de iniciar otra ronda con la misma configuración utilizando el botón ‘Jugar’ durante la ronda actual puede no estar disponible en el juego debido a la licencia que regula el trabajo del operador . En este caso, el botón «Jugar» permanecerá inactivo hasta que finalice la ronda actual y se muestren los resultados. Solo se puede jugar una ronda cada vez.</span></p>\n\n</div>\n\n<h2 id=\"retorno-al-jugador\">Retorno al jugador</h2>\n\n<p>El retorno teórico general al jugador (RTP) es {RTP.min_rtp}% - {RTP.max_rtp}% dependiendo de la estrategia elegida por el jugador.</p>\n\n<p>¡Un mal funcionamiento anula todas las jugadas y los pagos! Todas las rondas inacabadas se terminarán cada veinticuatro horas. Si el juego requiere «Recoger», se producirá la acción de «Recoger» y las ganancias de la ronda se añadirán al saldo del jugador. Si el juego requiere la acción de un jugador, el resultado se cuenta asumiendo que el jugador ha elegido la acción sin riesgo sin subir la apuesta inicial.</p>\n\n<p><span class=\"game_version\">versión de juego {game_version}.</span></p>\n\n<p>Las Reglas del juego publicadas en esta página web están en inglés, y las traducciones a otros idiomas se proporcionan como un servicio de buena fe. En caso de ambigüedad entre una versión inglesa y una traducción, la versión inglesa siempre tiene prioridad.</p>\n</div>\n","contentUpdateScript":"const casinoOptions = window.__OPTIONS__;\nlet customRulesStyle = '';\n\nif (casinoOptions?.math?.gamble_limit) {\n    content = content.replaceAll('{GAMBLE_LIMIT}', casinoOptions.math.gamble_limit);\n}\n\n//INFO: temporary solution for BGG-7896 & BGG-11170, but we need more flexible solution\nconst licenseDisabled = [\"empty\", \"switzerland\"];\nconst rulesLicense = casinoOptions?.license_rules?.license ?? \"empty\";\nif (licenseDisabled.includes(rulesLicense)) {\n    customRulesStyle += ` .license-block { display: none } `;\n}\n\nif (rulesLicense === \"empty\") {\n\tcustomRulesStyle += ` .license-block-casual { display: none } `;\n}\n\n// BGG-11165: Allow custom rules for any license\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license { display: none } `;\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license.${rulesLicense} { display: unset } `;\n\nif (casinoOptions?.ui?.show_rtp_in_rules === false) {\n    const rtpRegExp = /<h\\d[^>]*>[^>]*<\\/h\\d>[^<]*<p>[^<]*(\\{RTP.+\\}|\\d[^<]*%)[^<]*<\\/p>[^<]*/;\n\n    content = content.replace(rtpRegExp, '');\n}\n\nif (casinoOptions?.math?.rtp) {\n    if (!isNaN(casinoOptions.math.rtp)) {\n        casinoOptions.math.rtp = { main: casinoOptions.math.rtp };\n    }\n\n    content = content.replaceAll(`{RTP_VALUE}`, `{RTP.main}`);\n    Object.keys(casinoOptions.math.rtp).forEach((key) => {\n        content = content.replaceAll(`{RTP.${key}}`, casinoOptions.math.rtp[key]);\n    });\n}\n\nif (casinoOptions?.custom?.paytableFormatted) {\n    Object.keys(casinoOptions.custom.paytableFormatted).forEach((key) => {\n        content = content.replaceAll(`{PAYTABLE.${key}}`, casinoOptions.custom.paytableFormatted[key]);\n    });\n}\n\nif (casinoOptions?.custom?.wintableFormatted) {\n\tObject.keys(casinoOptions.custom.wintableFormatted).forEach((key) => {\n\t\tcontent = content.replaceAll(`{WIN.${key}}`, casinoOptions.custom.wintableFormatted[key]);\n\t});\n}\n\nif (casinoOptions?.custom?.maxWinsFormatted) {\n    casinoOptions.custom.maxWinsFormatted.forEach((winFormatted, index) => {\n        content = content.replaceAll(`{MAX_WIN.${index}}`, winFormatted);\n    });\n}\n\nif (casinoOptions?.custom?.betFormatted) {\n    content = content.replaceAll(`{BET_FORMATTED}`, casinoOptions.custom.betFormatted);\n}\n\nif (customRulesStyle !== '') {\n    content = '<style>' + customRulesStyle + '</style>' + content;\n}\n\nreturn content;\n\n","domScripts":["(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction formatBet(bet, subunits, exponent = 0) {\n    const betValue = bet / subunits;\n    let ret;\n\n    if (exponent > 0) {\n        let str = betValue.toFixed(exponent).split('.');\n        if (str[0].length > 3) {\n            str[0] = str[0].replace(/(.)(?=(.{3})+$)/g, '$1 ');\n        }\n        ret = str.join('.');\n    } else {\n        ret = betValue.toFixed(0).replace(/(.)(?=(.{3})+$)/g, '$1 ');\n    }\n    return ret;\n}\n\nfunction setMinMaxBets(options) {\n    const { rules, license_rules } = options;\n    const { min_bet, max_bet, currency } = rules || {};\n    const { symbol, exponent, subunits } = currency || {};\n\n    const isNeedToRemoveMinMaxBetBlock =\n        license_rules?.license !== 'switzerland' && license_rules?.license !== 'danish' && license_rules?.license !== 'swedish';\n    document.querySelectorAll('.min_max_bet').forEach((fragment) => {\n        if (isNeedToRemoveMinMaxBetBlock || (!min_bet && !max_bet)) {\n            fragment.remove();\n        } else {\n            const currencySymbol = symbol || '';\n            const minBet = formatBet(min_bet, subunits, exponent);\n            const maxBet = formatBet(max_bet, subunits, exponent);\n            fragment.textContent = fragment.textContent.replace('{min_bet}', `${minBet} ${currencySymbol}`);\n            fragment.textContent = fragment.textContent.replace('{max_bet}', `${maxBet} ${currencySymbol}`);\n        }\n    });\n}\n\nsetMinMaxBets(casinoOptions);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\nconst customLicenses = ['netherlands', 'swedish', 'italian', 'switzerland'];\n\nfunction handleCustomLicenses(options, customLicenses) {\n\tdocument.querySelectorAll('.casual_custom_license').forEach((fragment) => {\n\t\tif (!customLicenses.includes(options?.license_rules?.license)) {\n\t\t\tfragment.remove();\n\t\t}\n\t});\n}\n\nhandleCustomLicenses(casinoOptions, customLicenses);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction handleGameVersion(options) {\n    const gameVersion = options?.version;\n\n    document.querySelectorAll('.game_version').forEach((fragment) => {\n        if (!gameVersion) {\n            fragment.remove();\n        } else {\n            fragment.textContent = fragment.textContent.replaceAll('{game_version}', `${gameVersion}`);\n        }\n    });\n}\n\nhandleGameVersion(casinoOptions);\n\n})()\n","(()=>{\nconst PURCHASE_KEYS_REGEX = /buy|chance/;\nconst NETHERLANDS_RTP_TO_RENDER = /(main|chance)/;\n\nfunction getFinalRtpValues(options, isNeedRemovePurchasesRtp) {\n    const rtp = options?.math?.rtp ?? null;\n\n    if (!rtp || !isNeedRemovePurchasesRtp) return rtp;\n\n    return Object.entries(rtp).reduce((result, [rtpName, rtpValue]) => {\n        if (!PURCHASE_KEYS_REGEX.test(rtpName)) {\n            result[rtpName] = rtpValue;\n        }\n        return result;\n    }, {});\n}\n\nfunction removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemovePurchasesRtp && PURCHASE_KEYS_REGEX.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemoveRtp && !NETHERLANDS_RTP_TO_RENDER.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction replaceContent() {\n    const casinoOptions = window.__OPTIONS__;\n\n    const rulesLicense = casinoOptions?.license_rules?.license ?? 'empty';\n    const isNeedRemovePurchasesRtp = rulesLicense === 'greek';\n    const isNeedRemovePurchasesRtpForNetherlands = rulesLicense === 'netherlands';\n    const isNeedRemovePurchasesRtpForPortuguese = rulesLicense === 'portuguese';\n    const isNeedRemoveRtp = isNeedRemovePurchasesRtpForNetherlands || isNeedRemovePurchasesRtpForPortuguese;\n\n    const rtp = getFinalRtpValues(casinoOptions, isNeedRemovePurchasesRtp);\n    removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp);\n    removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp);\n}\n\nreplaceContent();\n\n})()\n"]}