{"content":"<div id=\"rules\">\n<h1 id=\"plinko-rules\">Plinko rules</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n\n<p>Plinko is the peculiar game of chance played with a ball “plinking” down the vertical board populated with offset rows of pegs, very popular game viewed on TV shows in the 20th century.  BGaming represented the board in the form of a pyramid. The gameplay is simple as it is: the player chooses from 8 to 16 rows, hoping the ball would fall into one of the chosen holes with the best payment, and just watches the “bouncing process through the obstacles” from the top of the pyramid down the board bottom. The ball eventually ends up at the bottom peg and determines the prize. So welcome to the Plinko’s plinkily intricate system, trust your luck and let the ball fall!</p>\n\n<h2 id=\"section\">กฎต่าง ๆ</h2>\n\n<p>The goal is to win money by dropping Plinko ball and wait till it lands in the highest money slot at the bottom of the board.</p>\n\n<h2 id=\"betting\">Betting</h2>\n\n<p>Сhoose the bet amount. Buttons <strong>“-”</strong>, <strong>“+”</strong>, <strong>“Min”</strong>, <strong>“Max”</strong> can be used. When the maximum amount is reached, the  buttons <strong>“+”</strong> and <strong>“Max”</strong> become disabled. When the minimum amount is reached, the buttons <strong>“-”</strong> and <strong>“Min”</strong> become disabled. Choose the Risk Level: Low, Normal or High. Choose the number of Lines in the game: from 8 to 16. Choose the Bet Mode: Manual or Auto.</p>\n\n<p>To start the game round press the <strong>Play</strong> button. All betting buttons become inactive at the time of the round except for <strong>Bet Mode</strong>. During the round, another round with the same settings using the <strong>Play</strong> button can be started. At the end of each round the ball reaches the pocket. The numbers displayed in each pocket represent multiplier values. The multiplier of the pocket, where the ball landed, is applied to the player’s bet. The final payout is calculated by multiplying the player’s bet by all the applicable multiplier values.</p>\n\n<p>In <strong>Auto Mode</strong>, the field with the number of automatic bets is shown. Choose the <strong>number of bets</strong>. Press <strong>Play</strong> button. The button <strong>Play</strong> is changing to <strong>Stop</strong> with the number of remained bets. A series of rounds can be completed if the number of rounds set  is reached, by clicking on the button <strong>Stop</strong>, if there are not enough funds on the balance.</p>\n\n<p><span class=\"min_max_bet\">The minimum bet value is {min_bet}. The maximum bet value is {max_bet}</span></p>\n\n<h2 id=\"results\">Results</h2>\n\n<p>The calculation of the win is made according to the paytable. The result is added to the balance field. The size of payments varies from low to high.</p>\n\n<div class=\"license-block-casual casual_custom_license\">\n\n  <h2 id=\"license-requirements\">License requirements</h2>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nThe Auto Mode can be unavailable in the game because of the requirements of the license that regulates the operator’s work.\n</span></p>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nQuick spins can be unavailable in the game because of the requirements of the license that regulates the operator’s work.\n</span></p>\n\n  <p><span class=\"casual_custom_license\"> The ability to start another round with the same settings using the ‘Play’ button during the current round may not be available in the game because of the license that regulates the operator’s work . In this case, the ‘Play’ button will remain inactive until the current round is completed and the results are displayed. Only one round can be played at a time.</span></p>\n\n</div>\n\n<h2 id=\"return-to-player\">Return to Player</h2>\n\n<p>The overall theoretical Return to Player (RTP) is {RTP.min_rtp}% - {RTP.max_rtp}% depending on the player’s chosen strategy.</p>\n\n<p>การทำงานผิดปกติจะยกเลิกการเล่นและการจ่ายเงินทั้งหมด! All unfinished rounds will be terminated every 24 hours. If the game requires “Collect” - “Collect” will take place and the win from the round will be added to the player balance. รอบที่ยังไม่จบทั้งหมดจะถูกยกเลิกแบบวันเว้นวัน หากเกมต้องการ “เก็บเงิน” การ “เก็บเงิน” จะเกิดขึ้น และรางวัลจากรอบนั้นจะบวกเพิ่มไปยังยอดเงินคงเหลือของผู้เล่น หากเกมต้องการการดำเนินการจากผู้เล่น ระบบจะนับผลลัพธ์โดยถือว่าผู้เล่นเลือกการกระทำที่ไม่มีความเสี่ยง โดยไม่มีการเพิ่มเงินเดิมพันเริ่มต้น</p>\n\n<p><span class=\"game_version\">Game Version {game_version}.</span></p>\n\n<p>The Game Rules as published on this website are in English. Translations into other languages are provided as a service in good faith. In the event of ambiguity between an English version and a translation, the English version always retains priority.</p>\n</div>\n","contentUpdateScript":"const casinoOptions = window.__OPTIONS__;\nlet customRulesStyle = '';\n\nif (casinoOptions?.math?.gamble_limit) {\n    content = content.replaceAll('{GAMBLE_LIMIT}', casinoOptions.math.gamble_limit);\n}\n\n//INFO: temporary solution for BGG-7896 & BGG-11170, but we need more flexible solution\nconst licenseDisabled = [\"empty\", \"switzerland\"];\nconst rulesLicense = casinoOptions?.license_rules?.license ?? \"empty\";\nif (licenseDisabled.includes(rulesLicense)) {\n    customRulesStyle += ` .license-block { display: none } `;\n}\n\nif (rulesLicense === \"empty\") {\n\tcustomRulesStyle += ` .license-block-casual { display: none } `;\n}\n\n// BGG-11165: Allow custom rules for any license\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license { display: none } `;\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license.${rulesLicense} { display: unset } `;\n\nif (casinoOptions?.ui?.show_rtp_in_rules === false) {\n    const rtpRegExp = /<h\\d[^>]*>[^>]*<\\/h\\d>[^<]*<p>[^<]*(\\{RTP.+\\}|\\d[^<]*%)[^<]*<\\/p>[^<]*/;\n\n    content = content.replace(rtpRegExp, '');\n}\n\nif (casinoOptions?.math?.rtp) {\n    if (!isNaN(casinoOptions.math.rtp)) {\n        casinoOptions.math.rtp = { main: casinoOptions.math.rtp };\n    }\n\n    content = content.replaceAll(`{RTP_VALUE}`, `{RTP.main}`);\n    Object.keys(casinoOptions.math.rtp).forEach((key) => {\n        content = content.replaceAll(`{RTP.${key}}`, casinoOptions.math.rtp[key]);\n    });\n}\n\nif (casinoOptions?.custom?.paytableFormatted) {\n    Object.keys(casinoOptions.custom.paytableFormatted).forEach((key) => {\n        content = content.replaceAll(`{PAYTABLE.${key}}`, casinoOptions.custom.paytableFormatted[key]);\n    });\n}\n\nif (casinoOptions?.custom?.wintableFormatted) {\n\tObject.keys(casinoOptions.custom.wintableFormatted).forEach((key) => {\n\t\tcontent = content.replaceAll(`{WIN.${key}}`, casinoOptions.custom.wintableFormatted[key]);\n\t});\n}\n\nif (casinoOptions?.custom?.maxWinsFormatted) {\n    casinoOptions.custom.maxWinsFormatted.forEach((winFormatted, index) => {\n        content = content.replaceAll(`{MAX_WIN.${index}}`, winFormatted);\n    });\n}\n\nif (casinoOptions?.custom?.betFormatted) {\n    content = content.replaceAll(`{BET_FORMATTED}`, casinoOptions.custom.betFormatted);\n}\n\nif (customRulesStyle !== '') {\n    content = '<style>' + customRulesStyle + '</style>' + content;\n}\n\nreturn content;\n\n","domScripts":["(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction formatBet(bet, subunits, exponent = 0) {\n    const betValue = bet / subunits;\n    let ret;\n\n    if (exponent > 0) {\n        let str = betValue.toFixed(exponent).split('.');\n        if (str[0].length > 3) {\n            str[0] = str[0].replace(/(.)(?=(.{3})+$)/g, '$1 ');\n        }\n        ret = str.join('.');\n    } else {\n        ret = betValue.toFixed(0).replace(/(.)(?=(.{3})+$)/g, '$1 ');\n    }\n    return ret;\n}\n\nfunction setMinMaxBets(options) {\n    const { rules, license_rules } = options;\n    const { min_bet, max_bet, currency } = rules || {};\n    const { symbol, exponent, subunits } = currency || {};\n\n    const isNeedToRemoveMinMaxBetBlock =\n        license_rules?.license !== 'switzerland' && license_rules?.license !== 'danish' && license_rules?.license !== 'swedish';\n    document.querySelectorAll('.min_max_bet').forEach((fragment) => {\n        if (isNeedToRemoveMinMaxBetBlock || (!min_bet && !max_bet)) {\n            fragment.remove();\n        } else {\n            const currencySymbol = symbol || '';\n            const minBet = formatBet(min_bet, subunits, exponent);\n            const maxBet = formatBet(max_bet, subunits, exponent);\n            fragment.textContent = fragment.textContent.replace('{min_bet}', `${minBet} ${currencySymbol}`);\n            fragment.textContent = fragment.textContent.replace('{max_bet}', `${maxBet} ${currencySymbol}`);\n        }\n    });\n}\n\nsetMinMaxBets(casinoOptions);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\nconst customLicenses = ['netherlands', 'swedish', 'italian', 'switzerland'];\n\nfunction handleCustomLicenses(options, customLicenses) {\n\tdocument.querySelectorAll('.casual_custom_license').forEach((fragment) => {\n\t\tif (!customLicenses.includes(options?.license_rules?.license)) {\n\t\t\tfragment.remove();\n\t\t}\n\t});\n}\n\nhandleCustomLicenses(casinoOptions, customLicenses);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction handleGameVersion(options) {\n    const gameVersion = options?.version;\n\n    document.querySelectorAll('.game_version').forEach((fragment) => {\n        if (!gameVersion) {\n            fragment.remove();\n        } else {\n            fragment.textContent = fragment.textContent.replaceAll('{game_version}', `${gameVersion}`);\n        }\n    });\n}\n\nhandleGameVersion(casinoOptions);\n\n})()\n","(()=>{\nconst PURCHASE_KEYS_REGEX = /buy|chance/;\nconst NETHERLANDS_RTP_TO_RENDER = /(main|chance)/;\n\nfunction getFinalRtpValues(options, isNeedRemovePurchasesRtp) {\n    const rtp = options?.math?.rtp ?? null;\n\n    if (!rtp || !isNeedRemovePurchasesRtp) return rtp;\n\n    return Object.entries(rtp).reduce((result, [rtpName, rtpValue]) => {\n        if (!PURCHASE_KEYS_REGEX.test(rtpName)) {\n            result[rtpName] = rtpValue;\n        }\n        return result;\n    }, {});\n}\n\nfunction removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemovePurchasesRtp && PURCHASE_KEYS_REGEX.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemoveRtp && !NETHERLANDS_RTP_TO_RENDER.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction replaceContent() {\n    const casinoOptions = window.__OPTIONS__;\n\n    const rulesLicense = casinoOptions?.license_rules?.license ?? 'empty';\n    const isNeedRemovePurchasesRtp = rulesLicense === 'greek';\n    const isNeedRemovePurchasesRtpForNetherlands = rulesLicense === 'netherlands';\n    const isNeedRemovePurchasesRtpForPortuguese = rulesLicense === 'portuguese';\n    const isNeedRemoveRtp = isNeedRemovePurchasesRtpForNetherlands || isNeedRemovePurchasesRtpForPortuguese;\n\n    const rtp = getFinalRtpValues(casinoOptions, isNeedRemovePurchasesRtp);\n    removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp);\n    removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp);\n}\n\nreplaceContent();\n\n})()\n"]}