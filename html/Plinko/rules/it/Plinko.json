{"content":"<div id=\"rules\">\n<h1 id=\"regole-di-plinko\">Regole di Plinko</h1>\n\n<h2 id=\"introduzione\">Introduzione</h2>\n\n<p>Plinko è quel gioco di fortuna particolare in cui una pallina scende rimbalzando (“plinking”) su un tabellone verticale costellato da file di pioli alternati. Era un gioco molto popolare nei programmi televisivi del secolo scorso.  BGaming ha rappresentato il tabellone sotto forma di piramide. Il gameplay è semplicissimo: il giocatore sceglie da 8 a 16 file, sperando che la pallina si fermi in una delle buche che offrono i premi migliori e deve solamente osservare i rimbalzi tra gli ostacoli dalla cima della piramide fino al fondo del tabellone. Alla fine, la pallina si fermerà in una delle buche inferiori, a cui è assegnato un premio. Quindi benvenuto al complesso sistema rimbalzante di Plinko. Fidati della tua buona stella e lascia cadere la pallina!</p>\n\n<h2 id=\"regole\">Regole</h2>\n\n<p>L’obiettivo è vincere premi in denaro facendo cadere la pallina Plinko e aspettare che cada nella buca con il premio più alto sul fondo del tabellone.</p>\n\n<h2 id=\"puntate\">Puntate</h2>\n\n<p>Scegli l’ammontare della puntata. Puoi usare i pulsanti <strong>“-”</strong>, <strong>“+”</strong>, <strong>“Min”</strong>, <strong>“Max”</strong>. Una volta raggiunta la puntata massima, i pulsanti <strong>“+”</strong> e <strong>“Max”</strong> non funzioneranno più. Una volta raggiunta la puntata minima, i pulsanti <strong>“-”</strong> e <strong>“Min”</strong> non funzioneranno più. Scegli il Livello di Rischio: Basso, Normale o Alto. Scegli il numero di File nel gioco: da 8 a 16. Scegli la Modalità di Puntata: Manuale o Automatica.</p>\n\n<p>Per avviare la partita, premi il pulsante <strong>Gioca</strong>. Tutti i pulsanti per modificare la puntata diventano inattivi una volta iniziata la partita, tranne <strong>Modalità di Puntata</strong>. Durante il gioco, puoi avviare un’altra partita con le stesse impostazioni usando il pulsante <strong>Gioca</strong>. Alla fine di ogni round, la pallina raggiungerà una tasca. I numeri visualizzati in ciascuna tasca rappresentano i valori del moltiplicatore. Il moltiplicatore della tasca in cui è atterrata la palla viene applicato alla puntata del giocatore. Il pagamento finale viene calcolato moltiplicando la puntata del giocatore per tutti i moltiplicatori applicabili.</p>\n\n<p>In <strong>Modalità automatica</strong>, viene mostrato il campo con il numero di puntate automatiche. Scegli il <strong>numero di puntate</strong>. Premi il pulsante <strong>Gioca</strong>. Il pulsante <strong>Gioca</strong> si trasforma in <strong>Stop</strong> con il numero di puntate rimaste. La serie di partite termina una volta raggiunto il numero di round impostati, cliccando sul pulsante <strong>Stop</strong> o se finiscono i crediti a tua disposizione.</p>\n\n<p><span class=\"min_max_bet\">Il valore minimo della puntata è {min_bet}. Il valore massimo della puntata è {max_bet}.</span></p>\n\n<h2 id=\"risultati\">Risultati</h2>\n\n<p>Il calcolo della vincita viene effettuato secondo la tabella dei pagamenti. Il risultato viene aggiunto al tuo saldo. L’ammontare della vincita varia da basso ad alto.</p>\n\n<div class=\"license-block-casual casual_custom_license\">\n\n  <h2 id=\"requisiti-di-licenza\">Requisiti di licenza</h2>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nLa modalità automatica può non essere disponibile nel gioco a causa dei requisiti della licenza che regola il lavoro dell’operatore.\n</span></p>\n\n  <p><span class=\"__OPTIONS__-license_rules-license netherlands\">\nGli spin rapidi possono non essere disponibili nel gioco a causa dei requisiti della licenza che regola il lavoro dell’operatore.\n</span></p>\n\n  <p><span class=\"casual_custom_license\">La possibilità di iniziare un altro round con le stesse impostazioni usando il pulsante “Gioca” durante il round corrente potrebbe non essere disponibile nel gioco a causa della licenza che regola il lavoro dell’operatore. In questo caso, il pulsante “Gioca” rimarrà inattivo fino a quando il round attuale non sarà completato e i risultati saranno visualizzati. Può essere giocato solo un round alla volta.</span></p>\n\n</div>\n\n<h2 id=\"ritorno-al-giocatore\">Ritorno al giocatore</h2>\n\n<p>Il Ritorno al Giocatore (RTP) teorico complessivo è del {RTP.min_rtp}% - {RTP.max_rtp}%, in base alla strategia scelta.</p>\n\n<p>In caso di malfunzionamento tutte le giocate e le vincite vengono annullate! Tutte le partite non terminate verranno chiuse ogni 24 ore. Se il gioco richiede la funzione “Riscuoti”, questa opzione verrà esercitata e la vincita della partita sarà aggiunta al saldo del giocatore. Se il gioco richiede un’azione da parte del giocatore, il risultato verrà conteggiato presumendo che il giocatore abbia scelto l’azione che non comporta rischi, senza aumentare la puntata iniziale.</p>\n\n<p><span class=\"game_version\">Versione Del Gioco {game_version}.</span></p>\n\n<p>Le Regole del Gioco pubblicate su questo sito web sono in inglese. Le traduzioni in altre lingue sono fornite come un servizio in buona fede. In caso di ambiguità tra la versione inglese e una traduzione, la versione inglese mantiene sempre la priorità.</p>\n</div>\n","contentUpdateScript":"const casinoOptions = window.__OPTIONS__;\nlet customRulesStyle = '';\n\nif (casinoOptions?.math?.gamble_limit) {\n    content = content.replaceAll('{GAMBLE_LIMIT}', casinoOptions.math.gamble_limit);\n}\n\n//INFO: temporary solution for BGG-7896 & BGG-11170, but we need more flexible solution\nconst licenseDisabled = [\"empty\", \"switzerland\"];\nconst rulesLicense = casinoOptions?.license_rules?.license ?? \"empty\";\nif (licenseDisabled.includes(rulesLicense)) {\n    customRulesStyle += ` .license-block { display: none } `;\n}\n\nif (rulesLicense === \"empty\") {\n\tcustomRulesStyle += ` .license-block-casual { display: none } `;\n}\n\n// BGG-11165: Allow custom rules for any license\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license { display: none } `;\ncustomRulesStyle += ` .__OPTIONS__-license_rules-license.${rulesLicense} { display: unset } `;\n\nif (casinoOptions?.ui?.show_rtp_in_rules === false) {\n    const rtpRegExp = /<h\\d[^>]*>[^>]*<\\/h\\d>[^<]*<p>[^<]*(\\{RTP.+\\}|\\d[^<]*%)[^<]*<\\/p>[^<]*/;\n\n    content = content.replace(rtpRegExp, '');\n}\n\nif (casinoOptions?.math?.rtp) {\n    if (!isNaN(casinoOptions.math.rtp)) {\n        casinoOptions.math.rtp = { main: casinoOptions.math.rtp };\n    }\n\n    content = content.replaceAll(`{RTP_VALUE}`, `{RTP.main}`);\n    Object.keys(casinoOptions.math.rtp).forEach((key) => {\n        content = content.replaceAll(`{RTP.${key}}`, casinoOptions.math.rtp[key]);\n    });\n}\n\nif (casinoOptions?.custom?.paytableFormatted) {\n    Object.keys(casinoOptions.custom.paytableFormatted).forEach((key) => {\n        content = content.replaceAll(`{PAYTABLE.${key}}`, casinoOptions.custom.paytableFormatted[key]);\n    });\n}\n\nif (casinoOptions?.custom?.wintableFormatted) {\n\tObject.keys(casinoOptions.custom.wintableFormatted).forEach((key) => {\n\t\tcontent = content.replaceAll(`{WIN.${key}}`, casinoOptions.custom.wintableFormatted[key]);\n\t});\n}\n\nif (casinoOptions?.custom?.maxWinsFormatted) {\n    casinoOptions.custom.maxWinsFormatted.forEach((winFormatted, index) => {\n        content = content.replaceAll(`{MAX_WIN.${index}}`, winFormatted);\n    });\n}\n\nif (casinoOptions?.custom?.betFormatted) {\n    content = content.replaceAll(`{BET_FORMATTED}`, casinoOptions.custom.betFormatted);\n}\n\nif (customRulesStyle !== '') {\n    content = '<style>' + customRulesStyle + '</style>' + content;\n}\n\nreturn content;\n\n","domScripts":["(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction formatBet(bet, subunits, exponent = 0) {\n    const betValue = bet / subunits;\n    let ret;\n\n    if (exponent > 0) {\n        let str = betValue.toFixed(exponent).split('.');\n        if (str[0].length > 3) {\n            str[0] = str[0].replace(/(.)(?=(.{3})+$)/g, '$1 ');\n        }\n        ret = str.join('.');\n    } else {\n        ret = betValue.toFixed(0).replace(/(.)(?=(.{3})+$)/g, '$1 ');\n    }\n    return ret;\n}\n\nfunction setMinMaxBets(options) {\n    const { rules, license_rules } = options;\n    const { min_bet, max_bet, currency } = rules || {};\n    const { symbol, exponent, subunits } = currency || {};\n\n    const isNeedToRemoveMinMaxBetBlock =\n        license_rules?.license !== 'switzerland' && license_rules?.license !== 'danish' && license_rules?.license !== 'swedish';\n    document.querySelectorAll('.min_max_bet').forEach((fragment) => {\n        if (isNeedToRemoveMinMaxBetBlock || (!min_bet && !max_bet)) {\n            fragment.remove();\n        } else {\n            const currencySymbol = symbol || '';\n            const minBet = formatBet(min_bet, subunits, exponent);\n            const maxBet = formatBet(max_bet, subunits, exponent);\n            fragment.textContent = fragment.textContent.replace('{min_bet}', `${minBet} ${currencySymbol}`);\n            fragment.textContent = fragment.textContent.replace('{max_bet}', `${maxBet} ${currencySymbol}`);\n        }\n    });\n}\n\nsetMinMaxBets(casinoOptions);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\nconst customLicenses = ['netherlands', 'swedish', 'italian', 'switzerland'];\n\nfunction handleCustomLicenses(options, customLicenses) {\n\tdocument.querySelectorAll('.casual_custom_license').forEach((fragment) => {\n\t\tif (!customLicenses.includes(options?.license_rules?.license)) {\n\t\t\tfragment.remove();\n\t\t}\n\t});\n}\n\nhandleCustomLicenses(casinoOptions, customLicenses);\n\n})()\n","(()=>{\nconst casinoOptions = window.__OPTIONS__;\n\nfunction handleGameVersion(options) {\n    const gameVersion = options?.version;\n\n    document.querySelectorAll('.game_version').forEach((fragment) => {\n        if (!gameVersion) {\n            fragment.remove();\n        } else {\n            fragment.textContent = fragment.textContent.replaceAll('{game_version}', `${gameVersion}`);\n        }\n    });\n}\n\nhandleGameVersion(casinoOptions);\n\n})()\n","(()=>{\nconst PURCHASE_KEYS_REGEX = /buy|chance/;\nconst NETHERLANDS_RTP_TO_RENDER = /(main|chance)/;\n\nfunction getFinalRtpValues(options, isNeedRemovePurchasesRtp) {\n    const rtp = options?.math?.rtp ?? null;\n\n    if (!rtp || !isNeedRemovePurchasesRtp) return rtp;\n\n    return Object.entries(rtp).reduce((result, [rtpName, rtpValue]) => {\n        if (!PURCHASE_KEYS_REGEX.test(rtpName)) {\n            result[rtpName] = rtpValue;\n        }\n        return result;\n    }, {});\n}\n\nfunction removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemovePurchasesRtp && PURCHASE_KEYS_REGEX.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp) {\n    document.querySelectorAll('[class*=\"rtp\"]').forEach((fragment) => {\n        const rtpName = fragment.className.replace('rtp-', '');\n        const isNeedRemoveStaticRtp = isNeedRemoveRtp && !NETHERLANDS_RTP_TO_RENDER.test(rtpName);\n        const isNeedRemoveDynamicRtp = rtp && !rtp[rtpName];\n\n        if (isNeedRemoveDynamicRtp || isNeedRemoveStaticRtp) {\n            fragment.parentElement.removeChild(fragment);\n        }\n    });\n}\n\nfunction replaceContent() {\n    const casinoOptions = window.__OPTIONS__;\n\n    const rulesLicense = casinoOptions?.license_rules?.license ?? 'empty';\n    const isNeedRemovePurchasesRtp = rulesLicense === 'greek';\n    const isNeedRemovePurchasesRtpForNetherlands = rulesLicense === 'netherlands';\n    const isNeedRemovePurchasesRtpForPortuguese = rulesLicense === 'portuguese';\n    const isNeedRemoveRtp = isNeedRemovePurchasesRtpForNetherlands || isNeedRemovePurchasesRtpForPortuguese;\n\n    const rtp = getFinalRtpValues(casinoOptions, isNeedRemovePurchasesRtp);\n    removeBonusRtpFromRules(rtp, isNeedRemovePurchasesRtp);\n    removeAllBonusRtpExeptChance(rtp, isNeedRemoveRtp);\n}\n\nreplaceContent();\n\n})()\n"]}